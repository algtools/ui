#!/usr/bin/env node

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Read the index.json generated by Storybook
const indexJsonPath = join(__dirname, '..', 'storybook-static', 'index.json');
const storiesJsonPath = join(__dirname, '..', 'storybook-static', 'stories.json');

console.log('Reading index.json...');
const indexDataRaw = JSON.parse(readFileSync(indexJsonPath, 'utf8'));
// Storybook 9.x uses { v: version, entries: {...} } structure
const indexData = indexDataRaw.entries || indexDataRaw;

// Helper function to extract prop information
function extractPropInfo(propContent) {
  const propInfo = {};

  // Extract control type
  const controlMatch = propContent.match(/control:\s*\{\s*type:\s*['"`]([^'"`]+)['"`]/);
  if (controlMatch) {
    propInfo.control = controlMatch[1];
  }

  // Extract options array - handle both single and multi-line
  const optionsMatch = propContent.match(/options:\s*\[([^\]]+)\]/s);
  if (optionsMatch) {
    const optionsStr = optionsMatch[1];
    propInfo.options = optionsStr
      .split(',')
      .map((opt) => {
        const trimmed = opt.trim().replace(/['"`]/g, '');
        return trimmed || null;
      })
      .filter(Boolean);
  }

  // Extract description - handle multi-line strings and template literals
  const descMatch =
    propContent.match(/description:\s*(['"`])([^'"`]+)\1/s) ||
    propContent.match(/description:\s*['"`]([^'"`]+)['"`]/);
  if (descMatch) {
    propInfo.description = (descMatch[2] || descMatch[1]).trim();
  }

  return propInfo;
}

// Extract component information from stories files using regex
function extractComponentInfo(storyData) {
  const importPath = storyData.importPath;
  if (!importPath) return null;

  const storyFilePath = join(__dirname, '..', importPath.replace('./', ''));

  if (!existsSync(storyFilePath)) {
    return null;
  }

  try {
    const storyContent = readFileSync(storyFilePath, 'utf8');

    const componentInfo = {
      props: {},
      description: null,
      argTypes: {},
    };

    // Extract description from parameters.docs.description.component
    // Match: description: { component: '...' }
    const descriptionMatch = storyContent.match(
      /description:\s*\{\s*component:\s*['"`]([^'"`]+)['"`]\s*\}/s
    );
    if (descriptionMatch) {
      componentInfo.description = descriptionMatch[1].trim();
    }

    // Extract argTypes - need to handle nested objects properly
    // Match the entire argTypes object including nested braces
    const argTypesStart = storyContent.indexOf('argTypes:');
    if (argTypesStart !== -1) {
      let braceCount = 0;
      let argTypesEnd = argTypesStart + 8; // length of "argTypes:"

      // Find the opening brace
      while (argTypesEnd < storyContent.length && storyContent[argTypesEnd] !== '{') {
        argTypesEnd++;
      }

      if (argTypesEnd < storyContent.length) {
        let startPos = argTypesEnd;
        braceCount = 1;
        argTypesEnd++;

        // Find matching closing brace
        while (argTypesEnd < storyContent.length && braceCount > 0) {
          if (storyContent[argTypesEnd] === '{') braceCount++;
          if (storyContent[argTypesEnd] === '}') braceCount--;
          argTypesEnd++;
        }

        const argTypesContent = storyContent.substring(startPos + 1, argTypesEnd - 1);

        // Extract each property in argTypes - simpler approach
        // Match: propName: { ... }
        const lines = argTypesContent.split('\n');
        let currentProp = null;
        let propContent = '';
        let braceLevel = 0;
        let inProp = false;

        for (const line of lines) {
          // Check if this line starts a new property
          const propMatch = line.match(/^\s*(\w+):\s*\{/);
          if (propMatch && !inProp) {
            // Save previous prop if exists
            if (currentProp && propContent.trim()) {
              const propInfo = extractPropInfo(propContent);
              if (Object.keys(propInfo).length > 0) {
                componentInfo.argTypes[currentProp] = propInfo;
              }
            }
            // Start new prop
            currentProp = propMatch[1];
            propContent = line;
            braceLevel = (line.match(/\{/g) || []).length - (line.match(/\}/g) || []).length;
            inProp = braceLevel > 0;
          } else if (inProp) {
            propContent += '\n' + line;
            braceLevel += (line.match(/\{/g) || []).length - (line.match(/\}/g) || []).length;
            if (braceLevel <= 0) {
              inProp = false;
              // Extract info from this prop
              const propInfo = extractPropInfo(propContent);
              if (Object.keys(propInfo).length > 0) {
                componentInfo.argTypes[currentProp] = propInfo;
              }
              currentProp = null;
              propContent = '';
            }
          }
        }

        // Handle last prop if still open
        if (currentProp && propContent.trim()) {
          const propInfo = extractPropInfo(propContent);
          if (Object.keys(propInfo).length > 0) {
            componentInfo.argTypes[currentProp] = propInfo;
          }
        }
      }
    }

    return Object.keys(componentInfo.argTypes).length > 0 || componentInfo.description
      ? componentInfo
      : null;
  } catch (error) {
    console.warn(`Could not parse ${storyFilePath}:`, error.message);
    return null;
  }
}

// Process all stories and enrich with component information
function enrichStories() {
  console.log('Enriching stories with component information...');

  const enrichedStories = { ...indexData };
  const processedComponents = new Map();

  for (const [storyId, storyData] of Object.entries(indexData)) {
    if (storyData.type !== 'docs') continue;

    const title = storyData.title;
    if (!title) continue;

    // Only process docs stories to get component info
    if (processedComponents.has(title)) continue;

    console.log(`Processing component: ${title}`);

    const componentInfo = extractComponentInfo(storyData);

    if (componentInfo) {
      processedComponents.set(title, componentInfo);

      // Add component info to all stories of this component
      for (const [id, story] of Object.entries(indexData)) {
        if (story.title === title) {
          enrichedStories[id] = {
            ...story,
            componentInfo: {
              props: componentInfo.argTypes,
              description: componentInfo.description,
            },
          };
        }
      }
    }
  }

  // Add a components summary at the root for easy access
  enrichedStories._components = {};
  for (const [title, info] of processedComponents.entries()) {
    const componentStories = Object.values(indexData).filter(
      (s) => s.title === title && s.type === 'story'
    );
    const firstStory =
      componentStories[0] || Object.values(indexData).find((s) => s.title === title);

    enrichedStories._components[title] = {
      title,
      componentPath: firstStory?.componentPath || null,
      importPath: firstStory?.importPath || null,
      description: info.description,
      props: info.argTypes,
      storyCount: componentStories.length,
      stories: componentStories.map((s) => ({
        id: s.id,
        name: s.name,
      })),
      storybookUrl: firstStory?.id
        ? `https://algtools.github.io/ui/?path=/story/${firstStory.id}`
        : null,
    };
  }

  console.log(`Enriched ${processedComponents.size} components`);
  return enrichedStories;
}

// Main execution
try {
  const enriched = enrichStories();
  writeFileSync(storiesJsonPath, JSON.stringify(enriched, null, 2), 'utf8');
  console.log(`✅ Enriched stories.json written to ${storiesJsonPath}`);
  console.log(
    `   - Total stories: ${Object.keys(enriched).filter((k) => !k.startsWith('_')).length}`
  );
  console.log(`   - Components with props: ${Object.keys(enriched._components || {}).length}`);
} catch (error) {
  console.error('❌ Error enriching stories:', error);
  process.exit(1);
}
